function [x,a,X,A] = frank_wolfe(op, x0,a0,lambda,options)

% frank_wolfe - Frank-Wolfe for BLASSO.
%
%   [x,a,X,A] = frank_wolfe(op, x0,a0,lambda,options);
%
%   Sove for 
%       min_{a,x} 1/2*|Phi_x*a-Phi_x0*a0|^2 + lambda*|a|_1
%   which is in fact a convex program over the space of measure, 
%   using the F-W method over the space of measures.
%
%   If a0 has length N, then x0 should have length N*d where d is the
%   dimension.
%
%   op should be generated by load_operator.
%
%   Parameters:
%       - options.fw_grid       : grid for the F-W step.
%       - options.niter_ista    : #iterations when using ista
%       - options.niter_bfgs    : #iterations when using bfgs
%       - options.niter         : overall #iterations of FW
%       - options.gridding_refine {0,1} : refine the grid search for the FW step by BFGS
%       - options.tol           : tolerance on l^inf norm of certificate for stopping
%       - options.fw_update in {'non-convex' 'ista'} : way to update (position,amplitude)
%       - options.pos_constr in {0 1} : impose positivity constraint on the solution.
%       - options.bfgs_solver in {'hanso' 'minconf'} : 
%           'hanso' seems more precise, but does not enforce constraints.
%           'minconf' imposes bound constraints on x as provided by op.xlim
%                   and op.ylim
%
%   Copyright (c) 2016 Gabriel Peyre

niter = getoptions(options, 'niter', 100);
fw_update = getoptions(options, 'fw_update', 'ista');
display = getoptions(options, 'display', 1); 
u = getoptions(options, 'fw_grid', []);
gridding_refine = getoptions(options, 'gridding_refine', 1);
tol = getoptions(options, 'tol', 1e-5); 
bfgs_solver = getoptions(options, 'bfgs_solver', 'hanso');
pos_constr = getoptions(options, 'pos_constr', 1);

% dimension
d = length(x0)/length(a0);
 % null measure as initialization
x = .5*ones(d,1); a = 0;

if d~=1 && d~=2
    error('Not implemented.');
end

if isempty(u)
    % default uniform grid
    switch d
        case 1
            u = linspace(op.xlim(1),op.xlim(2),512);
        case 2
            P = 256/16;
            xu = linspace(op.xlim(1),op.xlim(2),P);
            yu = linspace(op.ylim(1),op.ylim(2),P);
            [Yu,Xu] = meshgrid(yu,xu);
            u = [Xu(:);Yu(:)];
    end
end

% useful helpers in 2-D
X1 = @(x)x(1:end/2);
X2 = @(x)x(end/2+1:end);
resh = @(A)reshape(A, sqrt(length(A))*[1 1]);

X = {}; A = {}; 
for i=1:niter
    eta1 = op.eta(u,x,a,x0,a0,lambda);
    %%% F-W step: find intial new spike location at %%%
    if pos_constr==0
        % no positivity constraint, maximize |eta| 
        [~,k] = max(abs(eta1)); eta_max = eta1(k);
    else
        % positivity constraint, maximize eta
        [eta_max,k] = max(eta1);
    end
    switch d
        case 1
            u1 = u(k);
        case 2
            u1 = [u(k);u(end/2+k)];
    end
    %%% refine by gradient asscent on |eta| %%%
    if gridding_refine
        s = sign(eta_max);
        nablaEbfgs = @(z)deal(-s*op.eta(z,x,a,x0,a0,lambda),-s*op.etaD(z,x,a,x0,a0,lambda));
        switch bfgs_solver
            case 'hanso'
                opt.report = @(z,v)v;
                opt.verb = 0;
                opt.niter = getoptions(options, 'niter_bfgs', 100);
                [u2, R, info] = perform_bfgs(nablaEbfgs, u1, opt);
                eta_max = R(end);
                % to avoid problem, clamp to domain boundaries %
                u2(1) = clamp(u2(1),op.xlim(1),op.xlim(2));
                if d==2
                    u2(2) = clamp(u2(2),op.ylim(1),op.ylim(2));
                end
            case 'minconf'
                % N = length(u1)/2;
                % LB = [ones(N,1)*op.xlim(1);ones(N,1)*op.ylim(1)];
                LB = [op.xlim(1); op.ylim(1)];
                UB = [op.xlim(2); op.ylim(2)];
                opt.verbose = 0;
                opt.maxIter = getoptions(options, 'niter_bfgs', 100);
                opt.optTol = 1e-12;
                [u2,eta_max] = minConf_TMP(nablaEbfgs,u1,LB,UB,opt);
        end
                
    else
        u2=u1;
    end
    % display
    if display
        clf; hold on;
        switch d
            case 1
                plot(u, eta1, 'b');
                stem(x, a, 'b:.', 'MarkerSize', 10);
                stem(x0, a0, 'r:.', 'MarkerSize', 10);
                plot([min(u) max(u)], [1 1], 'k--');
                axis([min(u), max(u), .8, 1.1]);
            case 2                
                Q = sqrt(length(u)/2);
                xu = linspace(op.xlim(1),op.xlim(2),Q);
                yu = linspace(op.ylim(1),op.ylim(2),Q);
                imagesc(xu,yu,resh(eta1)');
                plot(X1(x0),X2(x0),'r.', 'MarkerSize', 20);
                plot(X1(x),X2(x),'k.', 'MarkerSize', 20);
                plot(X1(u2),X2(u2),'go', 'MarkerSize', 5);
                axis tight; axis square;
        end
        box on; drawnow;
    end    
    %%% stopping criteria %%%
    if abs(eta_max)<=1+tol
        % valid certificate, find global minimizer
        break; 
    end
    %%% add point %%%
    if i==1
        x = []; a = [];
    end
    switch d
        case 1
            x = [x;u2];
        case 2
            x = [X1(x);u2(1); X2(x);u2(2)];
    end
    a = [a;0]; % init
    %%% update spikes positions %%%
    switch fw_update
        case 'non-convex'
            % fist stay on the grid
            options.niter = getoptions(options, 'niter_ista', 100);
            [a,Err] = ista(op, x,a,x0,a0, lambda,options);
            % update the grid
            options.niter = getoptions(options, 'niter_bfgs', 100);
            options.verb = 0;
            [x,a,R] = noncvx_sparse_spikes(op,lambda, x0,a0, x,a, options);            
            % to avoid problem, clamp to domain boundaries %
            if d==1
                x = clamp(x,op.xlim(1),op.xlim(2));
            elseif d==2
                x(1:end/2)      = clamp(x(1:end/2),     op.xlim(1),op.xlim(2));
                x(end/2+1:end)  = clamp(x(end/2+1:end), op.ylim(1),op.ylim(2));
            end
        case 'ista'
            % stay on the grid
            options.niter = getoptions(options, 'niter_ista', 100);
            [a,Err] = ista(op, x,a,x0,a0, lambda,options);
    end
    % for book-keeping
    X{end+1} = x;
    A{end+1} = a; 
end

end